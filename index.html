<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>WebRTC Voice (SignalR + Free STUN/TURN)</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/6.0.1/signalr.min.js"></script>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; max-width: 720px; margin: 24px auto; padding: 0 16px; }
    h2 { margin-bottom: 8px; }
    .row { display: flex; gap: 8px; align-items: center; margin: 8px 0; flex-wrap: wrap; }
    input { padding: 8px; min-width: 260px; }
    button { padding: 8px 12px; cursor: pointer; border-radius: 8px; border: 1px solid #ddd; background: #f7f7f7; }
    .incoming { display:none; background: #fff7e6; border: 1px solid #ffd580; padding: 12px; border-radius: 8px; margin-top: 12px;}
    .log { background: #0d1117; color: #c9d1d9; padding: 12px; border-radius: 8px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px; height: 220px; overflow: auto; }
    .pill { padding: 2px 8px; border-radius: 999px; font-size: 12px; border: 1px solid #ddd; }
    audio { width: 100%; margin-top: 8px; }
  </style>
</head>
<body>
  <h2>WebRTC Voice (SignalR + Google STUN + OpenRelay TURN)</h2>

  <div class="row">
    <span class="pill">Your ID:</span>
    <span id="myId" style="font-weight:600">...</span>
    <button id="copyBtn">Copy</button>
  </div>

  <div class="row">
    <input id="targetId" placeholder="Enter target ID to call" />
    <button id="callBtn">üìû Call</button>
    <button id="hangupBtn" disabled>üõë Hang up</button>
  </div>

  <div id="incoming" class="incoming">
    <div>üì≤ Incoming call from <strong id="callerId"></strong></div>
    <div class="row" style="margin-top:8px;">
      <button id="acceptBtn">‚úÖ Accept</button>
      <button id="rejectBtn">‚ùå Reject</button>
    </div>
  </div>

  <h3>Remote Audio</h3>
  <audio id="remoteAudio" autoplay playsinline></audio>

  <h3>Logs</h3>
  <pre id="log" class="log"></pre>

<script>
  const SIGNALR_HUB_URL = "https://callhubtest-bwcmhjgcbbhcfebn.canadacentral-01.azurewebsites.net/callHub";
  const remoteAudioEl = document.getElementById("remoteAudio");
  const logEl = document.getElementById("log");

  let connection;
  let myId = null;
  let pc = null;
  let localStream = null;
  let pendingOffer = null;
  let callerId = null;
  let targetId = null;
  let remoteDescriptionSet = false;
  let candidateQueue = [];

  function log(...args) {
    const msg = args.map(a => (typeof a === "string" ? a : JSON.stringify(a))).join(" ");
    logEl.textContent += msg + "\n";
    logEl.scrollTop = logEl.scrollHeight;
    console.log(...args);
  }

  function showIncoming(fromId, show) {
    document.getElementById("incoming").style.display = show ? "block" : "none";
    if (show) document.getElementById("callerId").innerText = fromId || "";
  }

  async function getIceServers() {
    return [
      { urls: "stun:stun.l.google.com:19302" },
      { urls: "stun:stun1.l.google.com:19302" },
      { urls: "stun:stun2.l.google.com:19302" },
      {
        urls: [
          "turn:openrelay.metered.ca:80",
          "turn:openrelay.metered.ca:443?transport=tcp"
        ],
        username: "openrelayproject",
        credential: "openrelayproject"
      }
    ];
  }

  async function ensureMic() {
    if (!localStream) {
      localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      log("üé§ Mic granted");
    }
    return localStream;
  }

  function cleanupPeer() {
    if (pc) {
      try { pc.ontrack = null; } catch {}
      try { pc.onicecandidate = null; } catch {}
      try { pc.close(); } catch {}
      pc = null;
    }
    remoteDescriptionSet = false;
    candidateQueue = [];
    remoteAudioEl.srcObject = null;
    document.getElementById("hangupBtn").disabled = true;
  }

  async function createPeerConnection() {
    // üëâ Change "all" ‚Üí "relay" to test TURN-only mode
  const config = { iceServers: await getIceServers(), iceTransportPolicy: "relay" };
pc = new RTCPeerConnection(config);


    const stream = await ensureMic();
    stream.getTracks().forEach(t => pc.addTrack(t, stream));
    log("üì¶ Added mic tracks");

    pc.ontrack = (e) => {
      log("üîä ontrack received stream");
      remoteAudioEl.srcObject = e.streams[0];
    };

    pc.onicecandidate = (e) => {
      if (e.candidate) {
        const to = targetId || callerId;
        if (to) {
          connection.invoke("SendIceCandidate", to, JSON.stringify(e.candidate));
          log("‚û°Ô∏è Sent ICE candidate");
        }
      }
    };

    pc.oniceconnectionstatechange = () => {
      log("ICE state:", pc.iceConnectionState);
    };

    pc.onconnectionstatechange = () => {
      log("PC state:", pc.connectionState);
      if (pc.connectionState === "disconnected" || pc.connectionState === "failed" || pc.connectionState === "closed") {
        document.getElementById("hangupBtn").disabled = true;
      }
    };

    document.getElementById("hangupBtn").disabled = false;
  }

  async function addIceCandidateSafely(candidateJson) {
    const candidate = new RTCIceCandidate(JSON.parse(candidateJson));
    if (pc && remoteDescriptionSet) {
      try {
        await pc.addIceCandidate(candidate);
        log("‚¨ÖÔ∏è ICE candidate added immediately");
      } catch (err) {
        log("‚ö†Ô∏è addIceCandidate error:", err.message || err);
      }
    } else {
      candidateQueue.push(candidate);
      log("‚è≥ Queued ICE candidate (waiting for remoteDescription)");
    }
  }

  async function flushQueuedCandidates() {
    if (!pc || !remoteDescriptionSet || candidateQueue.length === 0) return;
    for (const c of candidateQueue) {
      try {
        await pc.addIceCandidate(c);
      } catch (err) {
        log("‚ö†Ô∏è addIceCandidate (flush) error:", err.message || err);
      }
    }
    candidateQueue = [];
    log("‚úÖ Flushed queued ICE candidates");
  }

  async function startCall() {
    targetId = document.getElementById("targetId").value.trim();
    if (!targetId) { alert("Enter target ID"); return; }
    log("üìû Starting call to:", targetId);

    await createPeerConnection();

    const offer = await pc.createOffer({ offerToReceiveAudio: true });
    await pc.setLocalDescription(offer);
    log("üì§ LocalDescription (offer) set");

    await connection.invoke("SendOffer", targetId, JSON.stringify(offer));
    log("‚û°Ô∏è Offer sent");
  }

  async function acceptCall() {
    showIncoming(null, false);
    log("‚úÖ Accepting call from:", callerId);

    await createPeerConnection();

    await pc.setRemoteDescription(new RTCSessionDescription(JSON.parse(pendingOffer)));
    remoteDescriptionSet = true;
    log("üì• RemoteDescription (offer) set");
    await flushQueuedCandidates();

    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);
    log("üì§ LocalDescription (answer) set");

    await connection.invoke("SendAnswer", callerId, JSON.stringify(answer));
    log("‚û°Ô∏è Answer sent to:", callerId);

    pendingOffer = null;
  }

  function rejectCall() {
    log("‚ùå Rejected call from:", callerId);
    showIncoming(null, false);
    pendingOffer = null;
    callerId = null;
  }

  async function hangUp() {
    log("üõë Hanging up");
    cleanupPeer();
  }

  async function startSignalR() {
    connection = new signalR.HubConnectionBuilder().withUrl(SIGNALR_HUB_URL).withAutomaticReconnect().build();

    connection.on("ReceiveConnectionId", (id) => {
      myId = id;
      document.getElementById("myId").innerText = id;
      log("üîó Connected. My ID:", id);
    });

    connection.on("ReceiveOffer", (fromId, offer) => {
      log("üì≤ Incoming offer from:", fromId);
      callerId = fromId;
      pendingOffer = offer;
      showIncoming(fromId, true);
    });

    connection.on("ReceiveAnswer", async (fromId, answer) => {
      log("üì© Answer received from:", fromId);
      if (!pc) { log("‚ö†Ô∏è No PC when answer arrived"); return; }
      await pc.setRemoteDescription(new RTCSessionDescription(JSON.parse(answer)));
      remoteDescriptionSet = true;
      log("üì• RemoteDescription (answer) set");
      await flushQueuedCandidates();
    });

    connection.on("ReceiveIceCandidate", async (fromId, candidateJson) => {
      log("‚¨áÔ∏è ICE candidate from:", fromId);
      await addIceCandidateSafely(candidateJson);
    });

    connection.onreconnecting(err => log("‚Ü©Ô∏è Reconnecting...", err?.message || ""));
    connection.onreconnected(id => log("‚úÖ Reconnected as:", id));
    connection.onclose(err => log("‚ùå Connection closed", err?.message || ""));

    await connection.start();
    log("‚úÖ SignalR connected");
  }

  document.getElementById("callBtn").addEventListener("click", startCall);
  document.getElementById("acceptBtn").addEventListener("click", acceptCall);
  document.getElementById("rejectBtn").addEventListener("click", rejectCall);
  document.getElementById("hangupBtn").addEventListener("click", hangUp);
  document.getElementById("copyBtn").addEventListener("click", async () => {
    try {
      await navigator.clipboard.writeText(myId || "");
      alert("Copied your ID");
    } catch {}
  });

  (async () => {
    try {
      await startSignalR();
      log("Ready. Share your ID with someone on the same hub.");
    } catch (e) {
      log("‚ùå Failed to start:", e.message || e);
    }
  })();
</script>
</body>
</html>
