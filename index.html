<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>WebRTC Voice (SignalR + Google STUN + Azure TURN)</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/6.0.1/signalr.min.js"></script>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; max-width: 720px; margin: 24px auto; padding: 0 16px; }
    h2 { margin-bottom: 8px; }
    .row { display: flex; gap: 8px; align-items: center; margin: 8px 0; flex-wrap: wrap; }
    input { padding: 8px; min-width: 260px; }
    button { padding: 8px 12px; cursor: pointer; border-radius: 8px; border: 1px solid #ddd; background: #f7f7f7; }
    .incoming { display:none; background: #fff7e6; border: 1px solid #ffd580; padding: 12px; border-radius: 8px; margin-top: 12px;}
    .log { background: #0d1117; color: #c9d1d9; padding: 12px; border-radius: 8px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px; height: 220px; overflow: auto; }
    .pill { padding: 2px 8px; border-radius: 999px; font-size: 12px; border: 1px solid #ddd; }
    audio { width: 100%; margin-top: 8px; }
  </style>
</head>
<body>
  <h2>WebRTC Voice (SignalR + Google STUN + Azure TURN)</h2>

  <div class="row">
    <span class="pill">Your ID:</span>
    <span id="myId" style="font-weight:600">...</span>
    <button id="copyBtn">Copy</button>
    <button id="enableSoundBtn" title="Helps if autoplay is blocked">üîä Enable sound</button>
  </div>

  <div class="row">
    <input id="targetId" placeholder="Enter target ID to call" />
    <button id="callBtn">üìû Call</button>
    <button id="hangupBtn" disabled>üõë Hang up</button>
  </div>

  <div id="incoming" class="incoming">
    <div>üì≤ Incoming call from <strong id="callerId"></strong></div>
    <div class="row" style="margin-top:8px;">
      <button id="acceptBtn">‚úÖ Accept</button>
      <button id="rejectBtn">‚ùå Reject</button>
    </div>
  </div>

  <h3>Remote Audio</h3>
  <audio id="remoteAudio" autoplay playsinline></audio>

  <h3>Logs</h3>
  <pre id="log" class="log"></pre>

<script>
  const SIGNALR_HUB_URL = "https://callhubtest-bwcmhjgcbbhcfebn.canadacentral-01.azurewebsites.net/callHub";
  const remoteAudioEl = document.getElementById("remoteAudio");
  const logEl = document.getElementById("log");

  let connection;
  let myId = null;
  let pc = null;
  let localStream = null;
  let pendingOffer = null;
  let callerId = null;
  let targetId = null;
  let remoteDescriptionSet = false;
  let candidateQueue = [];

  function log(...args) {
    const msg = args.map(a => (typeof a === "string" ? a : JSON.stringify(a))).join(" ");
    logEl.textContent += msg + "\n";
    logEl.scrollTop = logEl.scrollHeight;
    console.log(...args);
  }

  function showIncoming(fromId, show) {
    document.getElementById("incoming").style.display = show ? "block" : "none";
    if (show) document.getElementById("callerId").innerText = fromId || "";
  }

  // ‚úÖ Updated ICE Servers (Google STUN + Your Azure TURN)
  async function getIceServers() {
    return [
      { urls: "stun:stun.l.google.com:19302" },
      { urls: "stun:20.151.176.5:3478" },
      {
        urls: [
          "turn:20.151.176.5:3478?transport=udp",
          "turn:20.151.176.5:3478?transport=tcp"
        ],
        username: "webrtcuser",
        credential: "webrtccredential"
      }
    ];
  }

  // === Helper Functions for Debug ===
  function candidateTypeFromSDP(sdp) {
    const m = / typ (\w+) /.exec(sdp);
    return m ? m[1] : "unknown";
  }

  async function logSelectedCandidatePair(pc) {
    try {
      const stats = await pc.getStats();
      let selected;
      stats.forEach(report => {
        if (report.type === "transport" && report.selectedCandidatePairId) {
          selected = stats.get(report.selectedCandidatePairId);
        }
      });
      if (selected) {
        const local = stats.get(selected.localCandidateId);
        const remote = stats.get(selected.remoteCandidateId);
        log("‚≠ê Selected pair:", JSON.stringify({
          local: { ip: local?.ip, port: local?.port, type: local?.candidateType },
          remote: { ip: remote?.ip, port: remote?.port, type: remote?.candidateType }
        }));
      }
    } catch {}
  }

  async function ensureMic() {
    if (!localStream) {
      localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      log("üé§ Mic granted");
    }
    return localStream;
  }

  function cleanupPeer() {
    if (pc) {
      try { pc.close(); } catch {}
      pc = null;
    }
    remoteDescriptionSet = false;
    candidateQueue = [];
    remoteAudioEl.srcObject = null;
    document.getElementById("hangupBtn").disabled = true;
  }

  // ‚úÖ Updated createPeerConnection with debugging + FORCE_TURN flag
  async function createPeerConnection() {
    const iceServers = await getIceServers();
    const FORCE_TURN = false; // set true to test relay-only

    const config = {
      iceServers,
      iceTransportPolicy: FORCE_TURN ? "relay" : "all"
    };

    pc = new RTCPeerConnection(config);
    const stream = await ensureMic();
    stream.getTracks().forEach(t => pc.addTrack(t, stream));
    log("üì¶ Added mic tracks");

    pc.ontrack = (e) => {
      log("üîä ontrack:", e.streams?.length);
      remoteAudioEl.srcObject = e.streams[0];
      remoteAudioEl.play().catch(err => log("‚ö†Ô∏è play() error:", err.message));
    };

    pc.onicecandidate = (e) => {
      if (e.candidate) {
        const typ = candidateTypeFromSDP(e.candidate.candidate || "");
        log("‚û°Ô∏è Sent ICE candidate type:", typ);
        const to = targetId || callerId;
        if (to) connection.invoke("SendIceCandidate", to, JSON.stringify(e.candidate));
      }
    };

    pc.oniceconnectionstatechange = () => {
      log("ICE state:", pc.iceConnectionState);
      if (["connected", "completed"].includes(pc.iceConnectionState)) logSelectedCandidatePair(pc);
    };

    pc.onconnectionstatechange = () => log("PC state:", pc.connectionState);
    document.getElementById("hangupBtn").disabled = false;
  }

  async function addIceCandidateSafely(candidateJson) {
    const candidate = new RTCIceCandidate(JSON.parse(candidateJson));
    if (pc && remoteDescriptionSet) {
      await pc.addIceCandidate(candidate);
      log("‚¨ÖÔ∏è ICE candidate added");
    } else {
      candidateQueue.push(candidate);
      log("‚è≥ Queued ICE candidate");
    }
  }

  async function flushQueuedCandidates() {
    if (!pc || !remoteDescriptionSet || candidateQueue.length === 0) return;
    for (const c of candidateQueue) await pc.addIceCandidate(c);
    candidateQueue = [];
    log("‚úÖ Flushed queued ICE candidates");
  }

  async function startCall() {
    targetId = document.getElementById("targetId").value.trim();
    if (!targetId) return alert("Enter target ID");
    log("üìû Calling", targetId);

    await createPeerConnection();
    const offer = await pc.createOffer({ offerToReceiveAudio: true });
    await pc.setLocalDescription(offer);
    await connection.invoke("SendOffer", targetId, JSON.stringify(offer));
  }

  async function acceptCall() {
    showIncoming(null, false);
    await createPeerConnection();
    await pc.setRemoteDescription(new RTCSessionDescription(JSON.parse(pendingOffer)));
    remoteDescriptionSet = true;
    await flushQueuedCandidates();
    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);
    await connection.invoke("SendAnswer", callerId, JSON.stringify(answer));
  }

  function rejectCall() {
    showIncoming(null, false);
    pendingOffer = null;
  }

  async function hangUp() {
    log("üõë Hanging up");
    cleanupPeer();
  }

  async function startSignalR() {
    connection = new signalR.HubConnectionBuilder()
      .withUrl(SIGNALR_HUB_URL)
      .withAutomaticReconnect()
      .build();

    connection.on("ReceiveConnectionId", (id) => {
      myId = id;
      document.getElementById("myId").innerText = id;
      log("üîó Connected. My ID:", id);
    });

    connection.on("ReceiveOffer", (fromId, offer) => {
      log("üì≤ Incoming offer from:", fromId);
      callerId = fromId;
      pendingOffer = offer;
      showIncoming(fromId, true);
    });

    connection.on("ReceiveAnswer", async (fromId, answer) => {
      if (!pc) return;
      await pc.setRemoteDescription(new RTCSessionDescription(JSON.parse(answer)));
      remoteDescriptionSet = true;
      await flushQueuedCandidates();
      log("üì• Answer set");
    });

    connection.on("ReceiveIceCandidate", async (fromId, candidateJson) => {
      await addIceCandidateSafely(candidateJson);
    });

    await connection.start();
    log("‚úÖ SignalR connected");
  }

  // === UI Bindings ===
  document.getElementById("callBtn").addEventListener("click", startCall);
  document.getElementById("acceptBtn").addEventListener("click", acceptCall);
  document.getElementById("rejectBtn").addEventListener("click", rejectCall);
  document.getElementById("hangupBtn").addEventListener("click", hangUp);
  document.getElementById("copyBtn").addEventListener("click", async () => {
    try { await navigator.clipboard.writeText(myId || ""); alert("Copied!"); } catch {}
  });
  document.getElementById("enableSoundBtn").addEventListener("click", async () => {
    try { await remoteAudioEl.play(); } catch (e) { log("‚ö†Ô∏è play() failed:", e?.message); }
  });

  (async () => {
    try {
      await startSignalR();
      log("Ready. Share your ID with someone to start a call.");
    } catch (e) {
      log("‚ùå Failed to start:", e.message || e);
    }
  })();
</script>
</body>
</html>
